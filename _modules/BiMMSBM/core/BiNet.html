

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>BiMMSBM.core.BiNet &mdash; BiMMSBM 04/06/2025 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=27c3e253"></script>
      <script src="../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            BiMMSBM
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../Classes.html">Classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Functions.html">Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorial.html">Tutorial</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">BiMMSBM</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">BiMMSBM.core.BiNet</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for BiMMSBM.core.BiNet</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">from</span> <span class="nn">.metadata_layer</span> <span class="kn">import</span> <span class="n">metadata_layer</span>
<span class="kn">from</span> <span class="nn">.exclusive_metadata</span> <span class="kn">import</span> <span class="n">exclusive_metadata</span>
<span class="kn">from</span> <span class="nn">.inclusive_metadata</span> <span class="kn">import</span> <span class="n">inclusive_metadata</span>
<span class="kn">from</span> <span class="nn">.nodes_layer</span> <span class="kn">import</span> <span class="n">nodes_layer</span>
<span class="kn">from</span> <span class="nn">..functions</span> <span class="kn">import</span> <span class="o">*</span>


<div class="viewcode-block" id="BiNet">
<a class="viewcode-back" href="../../../Classes.html#BiMMSBM.core.BiNet">[docs]</a>
<span class="k">class</span> <span class="nc">BiNet</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class of a Bipartite Network, where two layers of different types of nodes are connected (users-&gt;items,</span>
<span class="sd">    politicians-&gt;bills, patient-&gt;microbiome...) and these links can be labeled with information of the</span>
<span class="sd">    interaction (ratings, votes...).</span>


<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    labels_name: str</span>
<span class="sd">        Name of the labels column</span>
<span class="sd">    N_labels: int</span>
<span class="sd">        Number of different types labels.</span>
<span class="sd">    labels_array: ndarray</span>
<span class="sd">        Array with all the ids of the labels.</span>
<span class="sd">    labels_name:</span>
<span class="sd">        List of the names of the diferents labels.</span>
<span class="sd">    labels_training:</span>
<span class="sd">        Array with all the ids of the labels used to train the MMSBM</span>
<span class="sd">    df:</span>
<span class="sd">        Dataframe with the links information, who connected to who and with which label are connected</span>
<span class="sd">    dict_codes: dict</span>
<span class="sd">        Dictionary with the integer ids of the labels. Keys are label names, and values are corresponding ids.</span>
<span class="sd">    nodes_a,nodes_b: nodes_layer</span>
<span class="sd">        nodes_layer objects of the nodes that are part from the bipartite network.</span>
<span class="sd">    links: 2D-array</span>
<span class="sd">        2D-array with the links of the nodes that are connected</span>
<span class="sd">    links_training: 2D-array</span>
<span class="sd">        2D-array with the links of the nodes that are connected used to train the MMSBM</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    __len__()</span>
<span class="sd">        Returns the number of different labels.</span>
<span class="sd">    __str__()</span>
<span class="sd">        Returns the name of the labels column.</span>

<span class="sd">    init_EM(tol=0.001, training=None, seed=None)</span>
<span class="sd">        Initializes the EM algorithm to find the most plausible membership parameters of the MMSBM.</span>

<span class="sd">    init_EM_from_directory(training=None, dir=&quot;.&quot;)</span>
<span class="sd">        Initializes the EM algorithm using parameters saved in files in a specified directory.</span>

<span class="sd">    EM_step(N_steps=1)</span>
<span class="sd">        Performs N_steps steps of the EM algorithm.</span>

<span class="sd">    get_log_likelihoods()</span>
<span class="sd">        Returns the loglikelihood of the current state of the MMSBM.</span>

<span class="sd">    get_links_probabilities(links=None)</span>
<span class="sd">        Returns the probability of each link in links.</span>

<span class="sd">    get_predicted_labels(links=None)</span>
<span class="sd">        Returns the predicted label of each link in links.</span>

<span class="sd">    get_accuracy(predicted_labels = None, test_labels = None, Pij = None,links = None, estimator = &quot;max_probability&quot;)</span>
<span class="sd">        Returns the accuracy of the predicted labels.</span>

<span class="sd">    deep_copying()</span>
<span class="sd">        Returns a deep copy of the BiNet instance.</span>

<span class="sd">    converges()</span>
<span class="sd">        Returns True if the EM algorithm has converged, False otherwise.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This class provides a structure to manage bipartite networks.</span>


<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="BiNet.__init__">
<a class="viewcode-back" href="../../../Classes.html#BiMMSBM.core.BiNet.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">links</span><span class="p">,</span> <span class="n">links_label</span><span class="p">,</span><span class="o">*</span><span class="p">,</span> <span class="n">nodes_a</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">nodes_b</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">Ka</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">nodes_a_name</span><span class="o">=</span><span class="s2">&quot;nodes_a&quot;</span><span class="p">,</span> <span class="n">Kb</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                 <span class="n">nodes_b_name</span><span class="o">=</span><span class="s2">&quot;nodes_b&quot;</span><span class="p">,</span> <span class="n">separator</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">dict_codes</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">dict_codes_a</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">dict_codes_b</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">         Initialization of a BiNet class</span>

<span class="sd">         Parameters</span>
<span class="sd">         -----------</span>
<span class="sd">         links: str, pandas DataFrame</span>
<span class="sd">            DataFrame or directory containing the links between nodes_a and nodes_b and their labels.</span>

<span class="sd">         links_label: str</span>
<span class="sd">             Name of the column where the labels are stored in the links DataFrame.</span>

<span class="sd">         nodes_a: nodes_layer, str, DataFrame, None, default: None</span>
<span class="sd">             One of the nodes layer that forms the bipartite network</span>
<span class="sd">             - If nodes_layer: Existing instance of the nodes_layer class representing the first layer.</span>
<span class="sd">             - If str or pd.DataFrame: If str, a directory containing the file information about nodes_a.</span>
<span class="sd">             - If pd.DataFrame, DataFrame with nodes_a information.</span>
<span class="sd">             - If None: A simple nodes_layer will be created from the information in links.</span>

<span class="sd">         nodes_b: nodes_layer, str, DataFrame, None, default: None</span>
<span class="sd">             One of the nodes layer that forms the bipartite network</span>
<span class="sd">             - If nodes_layer: Existing instance of the nodes_layer class representing the first layer.</span>
<span class="sd">             - If str or pd.DataFrame: If str, a directory containing the file information about nodes_b.</span>
<span class="sd">             - If pd.DataFrame, DataFrame with nodes_b information.</span>
<span class="sd">             - If None: A simple nodes_layer will be created from the information in links.</span>

<span class="sd">         Ka: int, default: 1</span>
<span class="sd">            Number of membership groups for nodes_a layer</span>

<span class="sd">         Kb: int, default: 1</span>
<span class="sd">            Number of membership groups for nodes_b layer</span>

<span class="sd">         nodes_a_name: str, default: nodes_a</span>
<span class="sd">            Name of the column where the names of nodes_a are in the links DataFrame and nodes_a DataFrame</span>

<span class="sd">         nodes_b_name: str, default: nodes_b</span>
<span class="sd">            Name of the column where the names of nodes_b are in the links DataFrame and nodes_b DataFrame</span>

<span class="sd">         dict_codes: dict, None, default: None</span>
<span class="sd">            Dictionary where the keys are the names of the labels, and the values are the ids. If None, new ids will be provided.</span>

<span class="sd">         dict_codes_a: dict, None, default: None</span>
<span class="sd">            Dictionary where the keys are the names of the nodes from nodes_a and the values are the ids. If None, new ids will be provided.</span>

<span class="sd">         dict_codes_b: dict, None, default: None</span>
<span class="sd">            Dictionary where the keys are the names of the nodes from nodes_b and the values are the ids. If None, new ids will be provided.</span>

<span class="sd">         separator: str, default: \t</span>
<span class="sd">            Separator used to read links DataFrame file. Default is \t</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#Checking type of links</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_separator</span> <span class="o">=</span> <span class="n">separator</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">links</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">df</span> <span class="o">=</span> <span class="n">links</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">links</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">links</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="n">separator</span><span class="p">,</span> <span class="n">engine</span><span class="o">=</span><span class="s1">&#39;python&#39;</span><span class="p">)</span>


        <span class="c1"># creating first layer class</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nodes_a</span><span class="p">,</span> <span class="n">nodes_layer</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span> <span class="o">=</span> <span class="n">nodes_a</span>
            <span class="n">nodes_a_name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="p">)</span>
            <span class="n">Ka</span> <span class="o">=</span> <span class="n">nodes_a</span><span class="o">.</span><span class="n">K</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nodes_a</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span> <span class="o">=</span> <span class="n">nodes_layer</span><span class="p">(</span><span class="n">Ka</span><span class="p">,</span> <span class="n">nodes_a_name</span><span class="p">,</span> <span class="n">nodes_a</span><span class="p">,</span> <span class="n">dict_codes</span> <span class="o">=</span> <span class="n">dict_codes_a</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nodes_a</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span> <span class="o">=</span> <span class="n">nodes_layer</span><span class="p">(</span><span class="n">Ka</span><span class="p">,</span> <span class="n">nodes_a_name</span><span class="p">,</span> <span class="n">nodes_a</span><span class="p">,</span> <span class="n">dict_codes</span> <span class="o">=</span> <span class="n">dict_codes_a</span><span class="p">)</span>
        <span class="k">elif</span>  <span class="n">nodes_a</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span> <span class="o">=</span> <span class="n">nodes_layer</span><span class="o">.</span><span class="n">create_simple_layer</span><span class="p">(</span><span class="n">Ka</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="n">nodes_a_name</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">(),</span> <span class="n">nodes_a_name</span><span class="p">,</span> <span class="n">dict_codes</span> <span class="o">=</span> <span class="n">dict_codes_a</span><span class="p">)</span>

        <span class="c1"># creating second layer class</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nodes_b</span><span class="p">,</span> <span class="n">nodes_layer</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span> <span class="o">=</span> <span class="n">nodes_b</span>
            <span class="n">nodes_b_name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="p">)</span>
            <span class="n">Kb</span> <span class="o">=</span> <span class="n">nodes_b</span><span class="o">.</span><span class="n">K</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nodes_b</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span> <span class="o">=</span> <span class="n">nodes_layer</span><span class="p">(</span><span class="n">Kb</span><span class="p">,</span> <span class="n">nodes_b_name</span><span class="p">,</span> <span class="n">nodes_b</span><span class="p">,</span> <span class="n">dict_codes</span> <span class="o">=</span> <span class="n">dict_codes_b</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nodes_b</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span> <span class="o">=</span> <span class="n">nodes_layer</span><span class="p">(</span><span class="n">Kb</span><span class="p">,</span> <span class="n">nodes_b_name</span><span class="p">,</span> <span class="n">nodes_b</span><span class="p">,</span> <span class="n">dict_codes</span> <span class="o">=</span> <span class="n">dict_codes_b</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">nodes_b</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span> <span class="o">=</span> <span class="n">nodes_layer</span><span class="o">.</span><span class="n">create_simple_layer</span><span class="p">(</span><span class="n">Kb</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="n">nodes_b_name</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">(),</span> <span class="n">nodes_b_name</span><span class="p">,</span> <span class="n">dict_codes</span> <span class="o">=</span> <span class="n">dict_codes_b</span><span class="p">)</span>


        <span class="c1">## Coding labels</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labels_name</span> <span class="o">=</span> <span class="n">links_label</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dict_codes</span> <span class="o">=</span> <span class="n">add_codes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">links_label</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dict_codes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1">#Checking type of labels</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">dtypes</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">labels_name</span><span class="p">]</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s2">&quot;int64&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">dtypes</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">labels_name</span><span class="p">]</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s2">&quot;int32&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">dtypes</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">labels_name</span><span class="p">]</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s2">&quot;int16&quot;</span><span class="p">):</span>
                <span class="n">new_dict</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">dict_codes</span><span class="p">:</span>
                    <span class="n">new_dict</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">k</span><span class="p">)]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">dict_codes</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
                <span class="n">dict_codes</span> <span class="o">=</span> <span class="n">new_dict</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_dict</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">dict_codes</span><span class="p">:</span>
                    <span class="n">dict_codes</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">dict_codes</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
                <span class="n">dict_codes</span> <span class="o">=</span> <span class="n">new_dict</span>

            <span class="n">replacer</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">att</span> <span class="ow">in</span> <span class="n">dict_codes</span><span class="p">:</span>
                <span class="n">replacer</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_dict_codes</span><span class="p">[</span><span class="n">att</span><span class="p">]]</span><span class="o">=</span> <span class="n">dict_codes</span><span class="p">[</span><span class="n">att</span><span class="p">]</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_dict_codes</span> <span class="o">=</span> <span class="n">dict_codes</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">replace</span><span class="p">({</span><span class="bp">self</span><span class="o">.</span><span class="n">labels_name</span><span class="o">+</span><span class="s2">&quot;_id&quot;</span><span class="p">:</span><span class="n">replacer</span><span class="p">},</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1">#Links</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="n">nodes_a_name</span> <span class="o">+</span> <span class="s2">&quot;_id&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">[[</span><span class="n">nodes_a_name</span><span class="p">]]</span><span class="o">.</span><span class="n">replace</span><span class="p">({</span><span class="n">nodes_a_name</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="o">.</span><span class="n">dict_codes</span><span class="p">})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="n">nodes_b_name</span> <span class="o">+</span> <span class="s2">&quot;_id&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">[[</span><span class="n">nodes_b_name</span><span class="p">]]</span><span class="o">.</span><span class="n">replace</span><span class="p">({</span><span class="n">nodes_b_name</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="o">.</span><span class="n">dict_codes</span><span class="p">})</span>


        <span class="bp">self</span><span class="o">.</span><span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labels_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="n">links_label</span> <span class="o">+</span> <span class="s2">&quot;_id&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">links</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">[[</span><span class="n">nodes_a_name</span> <span class="o">+</span> <span class="s2">&quot;_id&quot;</span><span class="p">,</span> <span class="n">nodes_b_name</span> <span class="o">+</span> <span class="s2">&quot;_id&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span>




        <span class="bp">self</span><span class="o">.</span><span class="n">N_labels</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labels_array</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span></div>



    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dict_codes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Dictionary with the integer ids of the labels. Keys are label names, and values are corresponding ids.</span>
<span class="sd">        The ids go from 0 to N_labels-1.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dict_codes</span>

    <span class="nd">@dict_codes</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">dict_codes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">dc</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Changes the ids (the integer assigned to each label) given the dict_codes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dict_codes</span> <span class="o">=</span> <span class="n">dc</span>
        <span class="k">return</span> <span class="n">dc</span>

<div class="viewcode-block" id="BiNet.load_BiNet_from_json">
<a class="viewcode-back" href="../../../Classes.html#BiMMSBM.core.BiNet.load_BiNet_from_json">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">load_BiNet_from_json</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">json_file</span><span class="p">,</span> <span class="n">links</span><span class="p">,</span> <span class="n">links_label</span><span class="p">,</span><span class="o">*</span><span class="p">,</span> <span class="n">nodes_a</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">nodes_b</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">nodes_a_dir</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">nodes_b_dir</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">separator</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load a BiNet instance from a JSON file containing MMSBM parameters and link information.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        json_file: str</span>
<span class="sd">            Path to the JSON files containing MMSBM parameters.</span>

<span class="sd">        links: str, pandas DataFrame</span>
<span class="sd">            DataFrame or directory containing the links between nodes_a and nodes_b and their labels.</span>

<span class="sd">        links_label: array-like</span>
<span class="sd">            Array-like object representing the labels corresponding to the links.</span>

<span class="sd">        nodes_a: nodes_layer, str, pd.DataFrame, None, default: None</span>
<span class="sd">            - If nodes_layer: Existing instance of the nodes_layer class representing the first layer.</span>
<span class="sd">            - If str or pd.DataFrame: If str, a name for the first layer. If pd.DataFrame, DataFrame with nodes and attributes.</span>
<span class="sd">            - If None: The first layer will be created later.</span>

<span class="sd">        nodes_b: nodes_layer, str, pd.DataFrame, None, default: None</span>
<span class="sd">            - If nodes_layer: Existing instance of the nodes_layer class representing the second layer.</span>
<span class="sd">            - If str or pd.DataFrame: If str, a name for the second layer. If pd.DataFrame, DataFrame with nodes and attributes.</span>
<span class="sd">            - If None: The second layer will be created later as a simple layer (no metadata)</span>

<span class="sd">        separator: str, default: &quot;\t&quot;</span>
<span class="sd">            Separator used in the provided JSON file.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        BN: BiNet</span>
<span class="sd">            Instance of the BiNet class loaded from the JSON file.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This class method allows loading a BiNet instance from a JSON file, along with links and labels. It constructs both</span>
<span class="sd">        nodes layers&#39; objects with metadata initialized based on the provided information.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#open json</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">json_file</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>


        <span class="c1">#construct both nodes layers objects with metadata initialized</span>
        <span class="c1"># creating first layer class</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nodes_a</span><span class="p">,</span> <span class="n">nodes_layer</span><span class="p">):</span>
            <span class="n">na</span> <span class="o">=</span> <span class="n">nodes_a</span>
            <span class="n">nodes_a_name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">na</span><span class="p">)</span>
            <span class="n">Ka</span> <span class="o">=</span> <span class="n">nodes_a</span><span class="o">.</span><span class="n">K</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nodes_a</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nodes_a</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">nodes_a_dir</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;If nodes_a is a string or a DataFrame, nodes_a_dir must be provided (the same for nodes_b).&quot;</span><span class="p">)</span>
            <span class="n">na</span> <span class="o">=</span> <span class="n">load_nodes_layer_from_file</span><span class="p">(</span><span class="n">nodes_a</span><span class="p">,</span> <span class="n">nodes_a_dir</span><span class="p">)</span>
            <span class="n">Ka</span> <span class="o">=</span> <span class="n">nodes_a</span><span class="o">.</span><span class="n">K</span>
        <span class="k">elif</span>  <span class="n">nodes_a</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1">#later it will be created</span>
            <span class="n">na</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># creating second layer class</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nodes_b</span><span class="p">,</span> <span class="n">nodes_layer</span><span class="p">):</span>
            <span class="n">nb</span> <span class="o">=</span> <span class="n">nodes_b</span>
            <span class="n">nodes_b_name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">nb</span><span class="p">)</span>
            <span class="n">Kb</span> <span class="o">=</span> <span class="n">nodes_b</span><span class="o">.</span><span class="n">K</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nodes_b</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nodes_b</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">nodes_b_dir</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;If nodes_b is a string or a DataFrame, nodes_b_dir must be provided (the same for nodes_a).&quot;</span><span class="p">)</span>
            <span class="n">nb</span> <span class="o">=</span> <span class="n">load_nodes_layer_from_file</span><span class="p">(</span><span class="n">nodes_b</span><span class="p">,</span> <span class="n">nodes_b_dir</span><span class="p">)</span>
            <span class="n">Kb</span> <span class="o">=</span> <span class="n">nodes_b</span><span class="o">.</span><span class="n">K</span>
        <span class="k">elif</span>  <span class="n">nodes_b</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1">#later it will be created</span>
            <span class="n">nb</span> <span class="o">=</span> <span class="kc">None</span>



        <span class="c1">#creating BiNet</span>
        <span class="k">if</span> <span class="n">na</span> <span class="o">==</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">nb</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">BN</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">links</span><span class="p">,</span><span class="n">links_label</span><span class="p">,</span>
                     <span class="n">nodes_a</span> <span class="o">=</span> <span class="n">na</span><span class="p">,</span> <span class="n">Ka</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;Ka&quot;</span><span class="p">],</span> <span class="n">nodes_a_name</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;nodes_a_name&quot;</span><span class="p">],</span>
                               <span class="n">dict_codes_a</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;dict_codes_a&quot;</span><span class="p">],</span>
                     <span class="n">nodes_b</span> <span class="o">=</span> <span class="n">nb</span><span class="p">,</span> <span class="n">Kb</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;Kb&quot;</span><span class="p">],</span> <span class="n">nodes_b_name</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;nodes_b_name&quot;</span><span class="p">],</span>
                               <span class="n">dict_codes_b</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;dict_codes_b&quot;</span><span class="p">],</span>
                     <span class="n">separator</span><span class="o">=</span><span class="n">separator</span><span class="p">,</span><span class="n">dict_codes</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;dict_codes&quot;</span><span class="p">])</span>



        <span class="k">elif</span> <span class="n">na</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">BN</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">links</span><span class="p">,</span><span class="n">links_label</span><span class="p">,</span>
                     <span class="n">nodes_a</span> <span class="o">=</span> <span class="n">na</span><span class="p">,</span> <span class="n">Ka</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;Ka&quot;</span><span class="p">],</span> <span class="n">nodes_a_name</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;nodes_a_name&quot;</span><span class="p">],</span>
                     <span class="n">nodes_b</span> <span class="o">=</span> <span class="n">nb</span><span class="p">,</span> <span class="n">separator</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;separator&quot;</span><span class="p">],</span><span class="n">dict_codes</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;dict_codes&quot;</span><span class="p">])</span>

        <span class="k">elif</span> <span class="n">nb</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">BN</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">links</span><span class="p">,</span><span class="n">links_label</span><span class="p">,</span>
                     <span class="n">nodes_a</span> <span class="o">=</span> <span class="n">na</span><span class="p">,</span>
                     <span class="n">nodes_b</span> <span class="o">=</span> <span class="n">nb</span><span class="p">,</span> <span class="n">Kb</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;K&quot;</span><span class="p">],</span> <span class="n">nodes_b_name</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;nodes_b_name&quot;</span><span class="p">],</span>
                     <span class="n">separator</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;separator&quot;</span><span class="p">],</span><span class="n">dict_codes</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;dict_codes&quot;</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">BN</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">links</span><span class="p">,</span><span class="n">links_label</span><span class="p">,</span>
                     <span class="n">nodes_a</span> <span class="o">=</span> <span class="n">na</span><span class="p">,</span>
                     <span class="n">nodes_b</span> <span class="o">=</span> <span class="n">nb</span><span class="p">,</span>
                     <span class="n">separator</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;separator&quot;</span><span class="p">],</span><span class="n">dict_codes</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;dict_codes&quot;</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">BN</span></div>


<div class="viewcode-block" id="BiNet.__getitem__">
<a class="viewcode-back" href="../../../Classes.html#BiMMSBM.core.BiNet.__getitem__">[docs]</a>
    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes_type</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the nodes_layer object of the specified type.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nodes_type: str</span>
<span class="sd">            Name of the nodes_layer object to return.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        nodes_layer</span>
<span class="sd">            The nodes_layer object of the specified type.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">nodes_type</span> <span class="o">==</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span>
        <span class="k">elif</span> <span class="n">nodes_type</span> <span class="o">==</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Nodes type </span><span class="si">{</span><span class="n">nodes_type</span><span class="si">}</span><span class="s2"> not found&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="BiNet.__setitem__">
<a class="viewcode-back" href="../../../Classes.html#BiMMSBM.core.BiNet.__setitem__">[docs]</a>
    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes_type</span><span class="p">,</span> <span class="n">nodes_layer</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the nodes_layer object of the specified type.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nodes_type: str</span>
<span class="sd">            Name of the nodes_layer object to set.</span>

<span class="sd">        nodes_layer: nodes_layer</span>
<span class="sd">            The nodes_layer object to set.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">nodes_type</span> <span class="o">==</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span> <span class="o">=</span> <span class="n">nodes_layer</span>
        <span class="k">elif</span> <span class="n">nodes_type</span> <span class="o">==</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span> <span class="o">=</span> <span class="n">nodes_layer</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Nodes type not found&quot;</span><span class="p">)</span></div>



    <span class="c1">#EM algorithm</span>
<div class="viewcode-block" id="BiNet.init_EM">
<a class="viewcode-back" href="../../../Classes.html#BiMMSBM.core.BiNet.init_EM">[docs]</a>
    <span class="k">def</span> <span class="nf">init_EM</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">tol</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span> <span class="n">training</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Initialize the EM algorithm to get the most plausible membership parameters of the MMSBM</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        tol : float, default: 0.001</span>
<span class="sd">            Tolerance of the algorithm when finding the parameters.</span>

<span class="sd">        seed : int, None, default: None</span>
<span class="sd">            Seed to generate the matrices. Is initialized using the np.random.RandomState(seed) method.</span>

<span class="sd">        training : DataFrame, list, default: None</span>
<span class="sd">            - If DataFrame: DataFrame with the links used to train the MMSBM.</span>
<span class="sd">            - If list or ndarray: List or array containing the indexes of the links list used for training.</span>
<span class="sd">            - If None: Uses self.links and self.labels_array.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method initializes the EM algorithm by setting up probability matrices (BiNet.pkl), memberships (BiNet.nodes_a.theta and BiNet.nodes_b.theta), and managing</span>
<span class="sd">        links to train. The tolerance, seed, and training data can be specified to customize the initialization process.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># Probability matrices</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">tol</span> <span class="o">=</span> <span class="n">tol</span>

        <span class="c1">#BiNet matrices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pkl</span> <span class="o">=</span> <span class="n">init_P_matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="o">.</span><span class="n">K</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="o">.</span><span class="n">K</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_labels</span><span class="p">)</span>

        <span class="c1">#memberships (thetas)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="o">.</span><span class="n">theta</span> <span class="o">=</span> <span class="n">init_P_matrix</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="p">),</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="o">.</span><span class="n">K</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="o">.</span><span class="n">theta</span> <span class="o">=</span> <span class="n">init_P_matrix</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="p">),</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="o">.</span><span class="n">K</span><span class="p">)</span>

        <span class="c1"># Links to train management</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">training</span><span class="p">,</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">links_training</span> <span class="o">=</span> <span class="n">training</span><span class="p">[[</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;_id&quot;</span><span class="p">,</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;_id&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">labels_training</span> <span class="o">=</span> <span class="n">training</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">labels_name</span><span class="o">+</span><span class="s2">&quot;_id&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">training</span><span class="p">,</span><span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">training</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">links_training</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">links</span><span class="p">[</span><span class="n">training</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">labels_training</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels_array</span><span class="p">[</span><span class="n">training</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">training</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">links_training</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">links</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">labels_training</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels_array</span>

        <span class="c1">#masks list to know wich links have label r (that is the index of the list)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">masks_label_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N_labels</span><span class="p">):</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labels_training</span><span class="o">==</span><span class="n">r</span><span class="p">)[:,</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">masks_label_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>

        <span class="c1">#observed nodes in each layer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">observed_nodes_a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">links_training</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">observed_nodes_b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">links_training</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1">#non_observed nodes in each layer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">non_observed_nodes_a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="p">))</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">observed_nodes_a</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">non_observed_nodes_b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="p">))</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">observed_nodes_b</span><span class="p">])</span>




        <span class="bp">self</span><span class="o">.</span><span class="n">omega</span> <span class="o">=</span> <span class="n">omega_comp_arrays</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="p">),</span><span class="bp">self</span><span class="o">.</span><span class="n">pkl</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="o">.</span><span class="n">theta</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="o">.</span><span class="n">theta</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="o">.</span><span class="n">K</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="o">.</span><span class="n">K</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">links_training</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">labels_training</span><span class="p">)</span>



        <span class="c1">#Metadata</span>
        <span class="c1">## qka and omegas</span>
        <span class="k">for</span> <span class="n">meta_name</span><span class="p">,</span><span class="n">meta</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="o">.</span><span class="n">meta_exclusives</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">meta</span><span class="o">.</span><span class="n">qka</span> <span class="o">=</span> <span class="n">init_P_matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="o">.</span><span class="n">K</span><span class="p">,</span> <span class="n">meta</span><span class="o">.</span><span class="n">N_att</span><span class="p">)</span>
            <span class="n">meta</span><span class="o">.</span><span class="n">omega</span> <span class="o">=</span> <span class="n">omega_comp_arrays_exclusive</span><span class="p">(</span><span class="n">meta</span><span class="o">.</span><span class="n">qka</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">N_att</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="o">.</span><span class="n">theta</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="p">),</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="o">.</span><span class="n">K</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">links</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">meta_name</span><span class="p">,</span><span class="n">meta</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="o">.</span><span class="n">meta_exclusives</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">meta</span><span class="o">.</span><span class="n">qka</span> <span class="o">=</span> <span class="n">init_P_matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="o">.</span><span class="n">K</span><span class="p">,</span> <span class="n">meta</span><span class="o">.</span><span class="n">N_att</span><span class="p">)</span>
            <span class="n">meta</span><span class="o">.</span><span class="n">omega</span> <span class="o">=</span> <span class="n">omega_comp_arrays_exclusive</span><span class="p">(</span><span class="n">meta</span><span class="o">.</span><span class="n">qka</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">N_att</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="o">.</span><span class="n">theta</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="p">),</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="o">.</span><span class="n">K</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">links</span><span class="p">)</span>

        <span class="c1">## q_k_tau, zetes and omegas omega_comp_arrays(omega,p_kl,theta,eta,K,L,links_array,links_ratings):</span>
        <span class="k">for</span> <span class="n">meta_name</span><span class="p">,</span><span class="n">meta</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="o">.</span><span class="n">meta_inclusives</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">meta</span><span class="o">.</span><span class="n">q_k_tau</span> <span class="o">=</span> <span class="n">init_P_matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="o">.</span><span class="n">K</span><span class="p">,</span> <span class="n">meta</span><span class="o">.</span><span class="n">Tau</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">meta</span><span class="o">.</span><span class="n">zeta</span> <span class="o">=</span> <span class="n">init_P_matrix</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">meta</span><span class="p">),</span> <span class="n">meta</span><span class="o">.</span><span class="n">Tau</span><span class="p">)</span>
            <span class="n">meta</span><span class="o">.</span><span class="n">omega</span> <span class="o">=</span> <span class="n">omega_comp_arrays</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">meta</span><span class="p">),</span><span class="n">meta</span><span class="o">.</span><span class="n">q_k_tau</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="o">.</span><span class="n">theta</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">zeta</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="o">.</span><span class="n">K</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">Tau</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">links</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">labels</span><span class="p">)</span>

            <span class="c1">#neighbours and denominators from meta</span>
            <span class="n">meta</span><span class="o">.</span><span class="n">denominators</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">meta</span><span class="p">))</span>

            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">meta</span><span class="p">)):</span>
                <span class="n">meta</span><span class="o">.</span><span class="n">denominators</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">meta</span><span class="o">.</span><span class="n">neighbours_meta</span><span class="p">[</span><span class="n">m</span><span class="p">])</span>
            <span class="n">meta</span><span class="o">.</span><span class="n">denominators</span> <span class="o">=</span> <span class="n">meta</span><span class="o">.</span><span class="n">denominators</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>



        <span class="k">for</span> <span class="n">meta_name</span><span class="p">,</span><span class="n">meta</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="o">.</span><span class="n">meta_inclusives</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">meta</span><span class="o">.</span><span class="n">q_k_tau</span> <span class="o">=</span> <span class="n">init_P_matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="o">.</span><span class="n">K</span><span class="p">,</span> <span class="n">meta</span><span class="o">.</span><span class="n">Tau</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">meta</span><span class="o">.</span><span class="n">zeta</span> <span class="o">=</span> <span class="n">init_P_matrix</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">meta</span><span class="p">),</span> <span class="n">meta</span><span class="o">.</span><span class="n">Tau</span><span class="p">)</span>
            <span class="n">meta</span><span class="o">.</span><span class="n">omega</span> <span class="o">=</span> <span class="n">omega_comp_arrays</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">meta</span><span class="p">),</span><span class="n">meta</span><span class="o">.</span><span class="n">q_k_tau</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="o">.</span><span class="n">theta</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">zeta</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="o">.</span><span class="n">K</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">Tau</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">links</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">labels</span><span class="p">)</span>

            <span class="c1">#neighbours and denominators from meta</span>
            <span class="n">meta</span><span class="o">.</span><span class="n">denominators</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">meta</span><span class="p">))</span>

            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">meta</span><span class="p">)):</span>
                <span class="n">meta</span><span class="o">.</span><span class="n">denominators</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">meta</span><span class="o">.</span><span class="n">neighbours_meta</span><span class="p">)</span>
            <span class="n">meta</span><span class="o">.</span><span class="n">denominators</span> <span class="o">=</span> <span class="n">meta</span><span class="o">.</span><span class="n">denominators</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>


        <span class="c1">#creating arrays with the denominator (that are constants) of each node in both layers and em layers</span>

        <span class="c1">##nodes a</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="o">.</span><span class="n">denominators</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">neighbours_nodes_a</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1">#list of list of neighbours</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="p">)):</span>
            <span class="c1">#neighbours in BiNet</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">neighbours_nodes_a</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">links_training</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">links_training</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="n">node</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="o">.</span><span class="n">denominators</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">neighbours_nodes_a</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1">#neighbours in meta exclusives</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">meta</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="o">.</span><span class="n">meta_exclusives</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">meta</span><span class="o">.</span><span class="n">links</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="o">.</span><span class="n">denominators</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">+=</span> <span class="n">meta</span><span class="o">.</span><span class="n">lambda_val</span>

        <span class="c1">#neighbours in meta inclusives</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">meta</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="o">.</span><span class="n">meta_inclusives</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="o">.</span><span class="n">denominators</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">+=</span> <span class="n">meta</span><span class="o">.</span><span class="n">lambda_val</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">meta</span><span class="o">.</span><span class="n">links</span><span class="p">[</span><span class="n">meta</span><span class="o">.</span><span class="n">links</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="n">node</span><span class="p">,:])</span>


            <span class="c1">#for i, meta in enumerate(self.nodes_a.meta_exclusives):</span>
                <span class="c1">#self.node_a.denominators[node] += meta.lambda_vals*</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="o">.</span><span class="n">denominators</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="o">.</span><span class="n">denominators</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

        <span class="c1">##nodes b</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="o">.</span><span class="n">denominators</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">neighbours_nodes_b</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1">#list of list of neighbours</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="p">)):</span>
            <span class="c1">#neighbours in BiNet</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">neighbours_nodes_b</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">links_training</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">links_training</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="n">node</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="o">.</span><span class="n">denominators</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">neighbours_nodes_b</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1">#neighbours in meta exclusives</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">meta</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="o">.</span><span class="n">meta_exclusives</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">meta</span><span class="o">.</span><span class="n">links</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="o">.</span><span class="n">denominators</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">+=</span> <span class="n">meta</span><span class="o">.</span><span class="n">lambda_val</span>

        <span class="c1">#neighbours in meta inclusives</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">meta</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="o">.</span><span class="n">meta_inclusives</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="o">.</span><span class="n">denominators</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">+=</span> <span class="n">meta</span><span class="o">.</span><span class="n">lambda_val</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">meta</span><span class="o">.</span><span class="n">links</span><span class="p">[</span><span class="n">meta</span><span class="o">.</span><span class="n">links</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="n">node</span><span class="p">,:])</span>

            <span class="c1">#neighbours in meta inclusives</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="o">.</span><span class="n">denominators</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="o">.</span><span class="n">denominators</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span></div>

            <span class="c1"># for meta in self.nodes_b.meta_exclusives:</span>

<div class="viewcode-block" id="BiNet.save_BiNet">
<a class="viewcode-back" href="../../../Classes.html#BiMMSBM.core.BiNet.save_BiNet">[docs]</a>
    <span class="k">def</span> <span class="nf">save_BiNet</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">dir</span><span class="o">=</span><span class="s2">&quot;.&quot;</span><span class="p">,</span><span class="n">layers</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        It saves the BiNet data into a JSON file in dir. If layers==True,</span>
<span class="sd">        it saves the nodes_layer objects in JSONs files in the same directory.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        dir: str</span>
<span class="sd">            Directory where the JSON with the BiNet information will be saved</span>
<span class="sd">        layers: bool, default: True</span>
<span class="sd">            If True, it saves the nodes_layer objects in JSONs files in the same directory.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">utils</span><span class="o">.</span><span class="n">save_BiNet_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">dir</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">layers</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="o">.</span><span class="n">save_nodes_layer</span><span class="p">(</span><span class="nb">dir</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="o">.</span><span class="n">save_nodes_layer</span><span class="p">(</span><span class="nb">dir</span><span class="p">)</span></div>


<div class="viewcode-block" id="BiNet.load_BiNet_from_file">
<a class="viewcode-back" href="../../../Classes.html#BiMMSBM.core.BiNet.load_BiNet_from_file">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">load_BiNet_from_file</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">df_links</span><span class="p">,</span><span class="n">json_dir</span><span class="p">,</span> <span class="n">layers</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="o">*</span><span class="p">,</span> <span class="n">nodes_a</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">nodes_b</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        It loads the BiNet data from a JSON file in dir</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        dir: str</span>
<span class="sd">            Directory where the JSON with the BiNet information is saved</span>
<span class="sd">        layers: bool, default: True</span>
<span class="sd">            If True, it loads the nodes_layer objects from the JSON file in the same directory.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">json_dir</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="n">BN</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">links</span><span class="o">=</span><span class="n">df_links</span><span class="p">,</span> <span class="o">**</span><span class="n">data</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">layers</span><span class="p">:</span>
            <span class="n">BN</span><span class="o">.</span><span class="n">nodes_a</span> <span class="o">=</span> <span class="n">nodes_layer</span><span class="o">.</span><span class="n">load_nodes_layer_from_file</span><span class="p">(</span><span class="n">json_dir</span><span class="p">)</span>
            <span class="n">BN</span><span class="o">.</span><span class="n">nodes_b</span> <span class="o">=</span> <span class="n">nodes_layer</span><span class="o">.</span><span class="n">load_nodes_layer_from_file</span><span class="p">(</span><span class="n">json_dir</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">nodes_a</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">BN</span><span class="o">.</span><span class="n">nodes_a</span> <span class="o">=</span> <span class="n">nodes_a</span>
            <span class="k">if</span> <span class="n">nodes_b</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">BN</span><span class="o">.</span><span class="n">nodes_b</span> <span class="o">=</span> <span class="n">nodes_b</span>
            


        
        <span class="k">return</span> <span class="n">BN</span></div>

    
    
<div class="viewcode-block" id="BiNet.init_EM_from_directory">
<a class="viewcode-back" href="../../../Classes.html#BiMMSBM.core.BiNet.init_EM_from_directory">[docs]</a>
    <span class="k">def</span> <span class="nf">init_EM_from_directory</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">training</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="nb">dir</span><span class="o">=</span><span class="s2">&quot;.&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Initialize the Expectation Maximization (EM) algorithm to obtain the most plausible membership parameters of the</span>
<span class="sd">        Mixed-Membership Stochastic Block Model (MMSBM) using parameters saved in files located in a specified directory.</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            dir: str, default: &quot;.&quot;</span>
<span class="sd">                Directory where the files with the MMSBM parameters will be loaded.</span>

<span class="sd">            training: pd.DataFrame, list, ndarray, default: None</span>
<span class="sd">                - If pd.DataFrame: DataFrame containing the training links and labels.</span>
<span class="sd">                - If list or ndarray: List or array containing the positions of the links list from self.df attribute.</span>
<span class="sd">                - If None: Uses self.links_training and self.labels_training.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">na</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span>

        <span class="n">nb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span>


        <span class="n">load_EM_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="nb">dir</span><span class="p">)</span>

        <span class="c1"># Links to train management</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">training</span><span class="p">,</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;_id&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">training</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="n">training</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;_id&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">training</span><span class="p">[[</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="p">)]]</span><span class="o">.</span><span class="n">replace</span><span class="p">({</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="p">):</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="o">.</span><span class="n">dict_codes</span><span class="p">})</span>
            <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;_id&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">training</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="n">training</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;_id&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">training</span><span class="p">[[</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="p">)]]</span><span class="o">.</span><span class="n">replace</span><span class="p">({</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="p">):</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="o">.</span><span class="n">dict_codes</span><span class="p">})</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">links_training</span> <span class="o">=</span> <span class="n">training</span><span class="p">[[</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;_id&quot;</span><span class="p">,</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;_id&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">labels_training</span> <span class="o">=</span> <span class="n">training</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">labels_name</span><span class="o">+</span><span class="s2">&quot;_id&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">training</span><span class="p">,</span><span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">training</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">links_training</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">links</span><span class="p">[</span><span class="n">training</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">labels_training</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels_array</span><span class="p">[</span><span class="n">training</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">training</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">links_training</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">links</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">labels_training</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels_array</span>

        <span class="c1">#Omegas and denominators</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">omega</span> <span class="o">=</span> <span class="n">omega_comp_arrays</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">na</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">nb</span><span class="p">),</span><span class="bp">self</span><span class="o">.</span><span class="n">pkl</span><span class="p">,</span><span class="n">na</span><span class="o">.</span><span class="n">theta</span><span class="p">,</span><span class="n">nb</span><span class="o">.</span><span class="n">theta</span><span class="p">,</span><span class="n">na</span><span class="o">.</span><span class="n">K</span><span class="p">,</span><span class="n">nb</span><span class="o">.</span><span class="n">K</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">links_training</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">labels_training</span><span class="p">)</span>


        <span class="c1">#masks list to know wich links have label r (that is the index of the list)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">masks_label_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N_labels</span><span class="p">):</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labels_training</span><span class="o">==</span><span class="n">r</span><span class="p">)[:,</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">masks_label_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>

        <span class="c1">#Metadata</span>
        <span class="c1">## qka and omegas</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">meta</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">na</span><span class="o">.</span><span class="n">meta_exclusives</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
            <span class="n">meta</span><span class="o">.</span><span class="n">omega</span> <span class="o">=</span> <span class="n">omega_comp_arrays_exclusive</span><span class="p">(</span><span class="n">meta</span><span class="o">.</span><span class="n">qka</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">N_att</span><span class="p">,</span><span class="n">na</span><span class="o">.</span><span class="n">theta</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">na</span><span class="p">),</span><span class="n">na</span><span class="o">.</span><span class="n">K</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">links</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">meta</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nb</span><span class="o">.</span><span class="n">meta_exclusives</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
            <span class="n">meta</span><span class="o">.</span><span class="n">omega</span> <span class="o">=</span> <span class="n">omega_comp_arrays_exclusive</span><span class="p">(</span><span class="n">meta</span><span class="o">.</span><span class="n">qka</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">N_att</span><span class="p">,</span><span class="n">nb</span><span class="o">.</span><span class="n">theta</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">nb</span><span class="p">),</span><span class="n">nb</span><span class="o">.</span><span class="n">K</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">links</span><span class="p">)</span>


        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">meta</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">na</span><span class="o">.</span><span class="n">meta_inclusives</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
            <span class="n">meta</span><span class="o">.</span><span class="n">omega</span> <span class="o">=</span> <span class="n">omega_comp_arrays</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">na</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">meta</span><span class="p">),</span><span class="n">meta</span><span class="o">.</span><span class="n">q_k_tau</span><span class="p">,</span><span class="n">na</span><span class="o">.</span><span class="n">theta</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">zeta</span><span class="p">,</span><span class="n">na</span><span class="o">.</span><span class="n">K</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">Tau</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">links</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">labels</span><span class="p">)</span>
            <span class="c1">#neighbours and denominators from meta</span>
            <span class="n">meta</span><span class="o">.</span><span class="n">denominators</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">meta</span><span class="p">))</span>

            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">meta</span><span class="p">)):</span>
                <span class="n">meta</span><span class="o">.</span><span class="n">denominators</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">meta</span><span class="o">.</span><span class="n">neighbours_meta</span><span class="p">[</span><span class="n">m</span><span class="p">])</span>
            <span class="n">meta</span><span class="o">.</span><span class="n">denominators</span> <span class="o">=</span> <span class="n">meta</span><span class="o">.</span><span class="n">denominators</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>



        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">meta</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nb</span><span class="o">.</span><span class="n">meta_inclusives</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
            <span class="n">meta</span><span class="o">.</span><span class="n">omega</span> <span class="o">=</span> <span class="n">omega_comp_arrays</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nb</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">meta</span><span class="p">),</span><span class="n">meta</span><span class="o">.</span><span class="n">q_k_tau</span><span class="p">,</span><span class="n">nb</span><span class="o">.</span><span class="n">theta</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">zeta</span><span class="p">,</span><span class="n">nb</span><span class="o">.</span><span class="n">K</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">Tau</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">links</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">labels</span><span class="p">)</span>

            <span class="c1">#neighbours and denominators from meta</span>
            <span class="n">meta</span><span class="o">.</span><span class="n">denominators</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">meta</span><span class="p">))</span>

            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">meta</span><span class="p">)):</span>
                <span class="n">meta</span><span class="o">.</span><span class="n">denominators</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">meta</span><span class="o">.</span><span class="n">neighbours_meta</span><span class="p">)</span>
            <span class="n">meta</span><span class="o">.</span><span class="n">denominators</span> <span class="o">=</span> <span class="n">meta</span><span class="o">.</span><span class="n">denominators</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>


        <span class="c1">#creating arrays with the denominator (that are constants) of each node in both layers and em layers</span>

        <span class="c1">##nodes a</span>
        <span class="n">na</span><span class="o">.</span><span class="n">denominators</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">na</span><span class="p">))</span>

        <span class="c1">#observed and nonobserved nodes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">observed_nodes_a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">links_training</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">non_observed_nodes_a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="p">))</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">observed_nodes_a</span><span class="p">])</span>


        <span class="bp">self</span><span class="o">.</span><span class="n">neighbours_nodes_a</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1">#list of list of neighbours</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">observed_nodes_a</span><span class="p">:</span>
            <span class="c1">#neighbours in BiNet</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">neighbours_nodes_a</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">links_training</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">links_training</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="n">node</span><span class="p">][:,</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">na</span><span class="o">.</span><span class="n">denominators</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">neighbours_nodes_a</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1">#neighbours in meta exclusives</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">meta</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">na</span><span class="o">.</span><span class="n">meta_exclusives</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">meta</span><span class="o">.</span><span class="n">links</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">na</span><span class="o">.</span><span class="n">denominators</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">+=</span> <span class="n">meta</span><span class="o">.</span><span class="n">lambda_val</span>

        <span class="c1">#neighbours in meta inclusives</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">na</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">meta</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">na</span><span class="o">.</span><span class="n">meta_inclusives</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
                <span class="n">na</span><span class="o">.</span><span class="n">denominators</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">+=</span> <span class="n">meta</span><span class="o">.</span><span class="n">lambda_val</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">meta</span><span class="o">.</span><span class="n">links</span><span class="p">[</span><span class="n">meta</span><span class="o">.</span><span class="n">links</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="n">node</span><span class="p">,:])</span>


        <span class="n">na</span><span class="o">.</span><span class="n">denominators</span> <span class="o">=</span> <span class="n">na</span><span class="o">.</span><span class="n">denominators</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>



        <span class="c1">##nodes b</span>
        <span class="c1">#observed and nonobserved nodes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">observed_nodes_b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">links_training</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">non_observed_nodes_b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="p">))</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">observed_nodes_b</span><span class="p">])</span>


        <span class="n">nb</span><span class="o">.</span><span class="n">denominators</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nb</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">neighbours_nodes_b</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1">#list of list of neighbours</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">observed_nodes_b</span><span class="p">:</span>
            <span class="c1">#neighbours in BiNet</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">neighbours_nodes_b</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">links_training</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">links_training</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="n">node</span><span class="p">][:,</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">nb</span><span class="o">.</span><span class="n">denominators</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">neighbours_nodes_b</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1">#neighbours in meta exclusives</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">meta</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nb</span><span class="o">.</span><span class="n">meta_exclusives</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">meta</span><span class="o">.</span><span class="n">links</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">nb</span><span class="o">.</span><span class="n">denominators</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">+=</span> <span class="n">meta</span><span class="o">.</span><span class="n">lambda_val</span>

        <span class="c1">#neighbours in meta inclusives</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nb</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">meta</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nb</span><span class="o">.</span><span class="n">meta_inclusives</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
                <span class="n">nb</span><span class="o">.</span><span class="n">denominators</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">+=</span> <span class="n">meta</span><span class="o">.</span><span class="n">lambda_val</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">meta</span><span class="o">.</span><span class="n">links</span><span class="p">[</span><span class="n">meta</span><span class="o">.</span><span class="n">links</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="n">node</span><span class="p">,:])</span>

            <span class="c1">#neighbours in meta inclusives</span>

        <span class="n">nb</span><span class="o">.</span><span class="n">denominators</span> <span class="o">=</span> <span class="n">nb</span><span class="o">.</span><span class="n">denominators</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span></div>



<div class="viewcode-block" id="BiNet.EM_step">
<a class="viewcode-back" href="../../../Classes.html#BiMMSBM.core.BiNet.EM_step">[docs]</a>
    <span class="k">def</span> <span class="nf">EM_step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">N_steps</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs the N_steps number of steps to update the model parameters.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        N_steps: int, default: 1</span>
<span class="sd">            Number of EM steps to be performed. Default is 1.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method updates the model parameters using the Expectation Maximization (EM) estimation.</span>
<span class="sd">        The Maximum a Posteriori algorithm is employed for iterative updates.</span>

<span class="sd">        During each step, the following updates are performed:</span>
<span class="sd">        - Update of nodes_a parameters (BiNet.nodes_a.theta).</span>
<span class="sd">        - Update of exclusive_meta and inclusive_meta for nodes_a (BiNet.nodes_a.meta.theta).</span>
<span class="sd">        - Update of nodes_b parameters ((BiNet.nodes_b.theta)).</span>
<span class="sd">        - Update of exclusive_meta and inclusive_meta for nodes_b (BiNet.nodes_b.meta.theta)..</span>
<span class="sd">        - Update of link probabilities (BiNet.pkl) and omega (BiNet.omega).</span>

<span class="sd">        After each step, a deep copy of the current model parameters is stored for convergence tracking.</span>

<span class="sd">        It is recommended to perform multiple EM steps to refine the model parameters.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1">#getting copies from the actual parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">deep_copying</span><span class="p">()</span>

        <span class="n">na</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span>

        <span class="n">nb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span>

        <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_steps</span><span class="p">):</span>

            <span class="k">for</span> <span class="n">layer</span><span class="p">,</span><span class="n">layer_str</span> <span class="ow">in</span> <span class="p">[(</span><span class="n">na</span><span class="p">,</span><span class="s2">&quot;a&quot;</span><span class="p">),(</span><span class="n">nb</span><span class="p">,</span><span class="s2">&quot;b&quot;</span><span class="p">)]:</span>
                <span class="c1">#layer update</span>
                <span class="c1"># print(f&quot;layer {layer} ({layer_str})&quot;)</span>
                <span class="c1"># print(f&quot;\t\t theta&quot;)</span>

                <span class="n">layer</span><span class="o">.</span><span class="n">theta</span> <span class="o">=</span> <span class="n">theta_comp_arrays_multilayer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">layer_str</span><span class="p">)</span>

                <span class="c1">##nodes_a exclusive_meta update</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">meta</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">layer</span><span class="o">.</span><span class="n">meta_exclusives</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
<span class="c1">#                     print(f&quot;\t\tmeta {meta}&quot;)</span>
                    <span class="n">meta</span><span class="o">.</span><span class="n">qka</span> <span class="o">=</span> <span class="n">q_ka_comp_arrays</span><span class="p">(</span><span class="n">layer</span><span class="o">.</span><span class="n">K</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">N_att</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">omega</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">links</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">masks_att_list</span><span class="p">)</span>
                    <span class="n">meta</span><span class="o">.</span><span class="n">omega</span> <span class="o">=</span> <span class="n">omega_comp_arrays_exclusive</span><span class="p">(</span><span class="n">meta</span><span class="o">.</span><span class="n">qka</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">N_att</span><span class="p">,</span><span class="n">layer</span><span class="o">.</span><span class="n">theta</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">layer</span><span class="p">),</span><span class="n">layer</span><span class="o">.</span><span class="n">K</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">links</span><span class="p">)</span>


                <span class="c1">##nodes_a inclusive_meta update</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">meta</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">layer</span><span class="o">.</span><span class="n">meta_inclusives</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
                    <span class="c1">#print(f&quot;\t\tmeta: {meta}&quot;)</span>
                    <span class="n">meta</span><span class="o">.</span><span class="n">zeta</span> <span class="o">=</span> <span class="n">theta_comp_array</span><span class="p">(</span><span class="n">meta</span><span class="o">.</span><span class="n">N_att</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">Tau</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">omega</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">denominators</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">links</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">masks_att_list</span><span class="p">)</span>
                    <span class="n">meta</span><span class="o">.</span><span class="n">q_k_tau</span> <span class="o">=</span> <span class="n">p_kl_comp_arrays</span><span class="p">(</span><span class="n">layer</span><span class="o">.</span><span class="n">K</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">Tau</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">links</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">omega</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">masks_label_list</span><span class="p">)</span>
                    <span class="n">meta</span><span class="o">.</span><span class="n">omega</span> <span class="o">=</span> <span class="n">omega_comp_arrays</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">layer</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">meta</span><span class="p">),</span><span class="n">meta</span><span class="o">.</span><span class="n">q_k_tau</span><span class="p">,</span><span class="n">layer</span><span class="o">.</span><span class="n">theta</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">zeta</span><span class="p">,</span><span class="n">layer</span><span class="o">.</span><span class="n">K</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">Tau</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">links</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">labels</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">pkl</span> <span class="o">=</span> <span class="n">p_kl_comp_arrays</span><span class="p">(</span><span class="n">na</span><span class="o">.</span><span class="n">K</span><span class="p">,</span><span class="n">nb</span><span class="o">.</span><span class="n">K</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">N_labels</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">links_training</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">masks_label_list</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">omega</span> <span class="o">=</span> <span class="n">omega_comp_arrays</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="p">),</span><span class="bp">self</span><span class="o">.</span><span class="n">pkl</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="o">.</span><span class="n">theta</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="o">.</span><span class="n">theta</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="o">.</span><span class="n">K</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="o">.</span><span class="n">K</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">links_training</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">labels_training</span><span class="p">)</span></div>



<div class="viewcode-block" id="BiNet.get_log_likelihoods">
<a class="viewcode-back" href="../../../Classes.html#BiMMSBM.core.BiNet.get_log_likelihoods">[docs]</a>
    <span class="k">def</span> <span class="nf">get_log_likelihoods</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        It computes the log_likelihoods from every bipartite network of the multipartite network, that means the log_likelihoods of the BiNet network and the log_likelihoods of the metadata networks.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">na</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span>

        <span class="n">nb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span>

        <span class="c1">#log-like from the labels network</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log_likelihood</span> <span class="o">=</span> <span class="n">log_like_comp</span><span class="p">(</span><span class="n">na</span><span class="o">.</span><span class="n">theta</span><span class="p">,</span><span class="n">nb</span><span class="o">.</span><span class="n">theta</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">pkl</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">links_training</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">labels_training</span><span class="p">)</span>

        <span class="c1">#log-like from the metadata networks</span>
        <span class="k">for</span> <span class="n">layer</span> <span class="ow">in</span> <span class="p">[</span><span class="n">na</span><span class="p">,</span><span class="n">nb</span><span class="p">]:</span>
            <span class="c1">#log-like inclusives meta</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">meta</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">layer</span><span class="o">.</span><span class="n">meta_inclusives</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
                <span class="n">meta</span><span class="o">.</span><span class="n">log_likelihood</span> <span class="o">=</span> <span class="n">log_like_comp</span><span class="p">(</span><span class="n">layer</span><span class="o">.</span><span class="n">theta</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">zeta</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">q_k_tau</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">links</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">labels</span><span class="p">)</span>
            <span class="c1">#log-like exclusives meta</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">meta</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">layer</span><span class="o">.</span><span class="n">meta_exclusives</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
                <span class="n">meta</span><span class="o">.</span><span class="n">log_likelihood</span> <span class="o">=</span> <span class="n">log_like_comp_exclusive</span><span class="p">(</span><span class="n">layer</span><span class="o">.</span><span class="n">theta</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">qka</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">links</span><span class="p">)</span></div>


<div class="viewcode-block" id="BiNet.get_links_probabilities">
<a class="viewcode-back" href="../../../Classes.html#BiMMSBM.core.BiNet.get_links_probabilities">[docs]</a>
    <span class="k">def</span> <span class="nf">get_links_probabilities</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">links</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the label probabilities for links in the trained BiNet.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        links : ndarray or DataFrame, optional, default: None</span>
<span class="sd">            Array or DataFrame with links for which probabilities are computed.</span>
<span class="sd">            - If 2D array, the first column should contain node IDs from nodes_a layer, and the second column from nodes_b layer.</span>
<span class="sd">            - If 1D array, it should contain positions of links in self.df attribute.</span>
<span class="sd">            - If DataFrame, it should have at least two columns with names of the nodes layers.</span>
<span class="sd">            - If None, self.links_training will be used.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Pij_r : ndarray, shape (len(links), self.N_labels)</span>
<span class="sd">            Pij_r[l, r] is the probability that link l has label r.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">links</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Pij</span> <span class="o">=</span> <span class="n">total_p_comp_test</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="o">.</span><span class="n">theta</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="o">.</span><span class="n">theta</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">pkl</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">links_training</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">links</span><span class="p">,</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
            <span class="n">N</span> <span class="o">=</span> <span class="n">links</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">isin</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;_id&quot;</span><span class="p">,</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;_id&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">N</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
                <span class="n">links</span> <span class="o">=</span> <span class="n">links</span><span class="p">[[</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;_id&quot;</span><span class="p">,</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;_id&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span>
            <span class="k">elif</span> <span class="n">N</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">links</span> <span class="o">=</span> <span class="n">links</span><span class="p">[[</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="p">),</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="p">)]]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">to_replace</span><span class="o">=</span><span class="p">{</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="p">):</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="o">.</span><span class="n">dict_codes</span><span class="p">,</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="p">):</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="o">.</span><span class="n">dict_codes</span><span class="p">})</span><span class="o">.</span><span class="n">values</span>
            <span class="k">elif</span> <span class="n">N</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">links</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">isin</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;_id&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                    <span class="n">links</span> <span class="o">=</span> <span class="n">links</span><span class="p">[[</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;_id&quot;</span><span class="p">,</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="p">)]]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">to_replace</span><span class="o">=</span><span class="p">{</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="p">):</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="o">.</span><span class="n">dict_codes</span><span class="p">})</span><span class="o">.</span><span class="n">values</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">links</span> <span class="o">=</span> <span class="n">links</span><span class="p">[[</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="p">),</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;_id&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">to_replace</span><span class="o">=</span><span class="p">{</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="p">):</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="o">.</span><span class="n">dict_codes</span><span class="p">})</span><span class="o">.</span><span class="n">values</span>

            <span class="n">Pij</span> <span class="o">=</span> <span class="n">total_p_comp_test</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="o">.</span><span class="n">theta</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="o">.</span><span class="n">theta</span><span class="p">,</span>
                                            <span class="bp">self</span><span class="o">.</span><span class="n">pkl</span><span class="p">,</span><span class="n">links</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">links</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">Pij</span> <span class="o">=</span> <span class="n">total_p_comp_test</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="o">.</span><span class="n">theta</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="o">.</span><span class="n">theta</span><span class="p">,</span>
                                            <span class="bp">self</span><span class="o">.</span><span class="n">pkl</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">links</span><span class="p">[</span><span class="n">links</span><span class="p">])</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">links</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">Pij</span> <span class="o">=</span> <span class="n">total_p_comp_test</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="o">.</span><span class="n">theta</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="o">.</span><span class="n">theta</span><span class="p">,</span>
                                            <span class="bp">self</span><span class="o">.</span><span class="n">pkl</span><span class="p">,</span><span class="n">links</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">Pij</span></div>



<div class="viewcode-block" id="BiNet.get_predicted_labels">
<a class="viewcode-back" href="../../../Classes.html#BiMMSBM.core.BiNet.get_predicted_labels">[docs]</a>
    <span class="k">def</span> <span class="nf">get_predicted_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">links</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">Pij</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>  <span class="n">estimator</span> <span class="o">=</span> <span class="s2">&quot;max_probability&quot;</span><span class="p">,</span> <span class="n">to_return</span> <span class="o">=</span> <span class="s2">&quot;df&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Computes the predicted labels of the model based on the MMSBM parameters, using different estimators. They can be measured by different estimators:</span>
<span class="sd">            - max_probability: The predicted label will be the most plausible label</span>
<span class="sd">            - mean: The predicted label will be the mean</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        links: ndarray of 1 or 2 dimensions, pandas DataFrame, default: None</span>
<span class="sd">            Array with links for which label probabilities are computed.</span>
<span class="sd">            -If a 2d-array, the first column must contain the ids from nodes_a layer and the second</span>
<span class="sd">             column must contain the ids from nodes_b layers.</span>
<span class="sd">            -If a 1d-array, it must contain the positions of the links list from self.df attribute</span>
<span class="sd">            -If a pandas DataFrame, it must contain at least two columns with the name of the nodes&#39; layers</span>
<span class="sd">             and a column with the same name as the labels column from BiNet.df.</span>
<span class="sd">            -If None, self.links_training will be used.</span>

<span class="sd">        Pij: ndarray, default: None</span>
<span class="sd">            Array with the probabilities of the links to have each label. If None, it will compute the probabilities using self.get_links_probabilities(links).</span>

<span class="sd">        estimator: {&quot;max_probability&quot;,&quot;average&quot;}, default: max_probability</span>
<span class="sd">            Estimator used to get predicted labels:</span>
<span class="sd">            - &quot;max_probability&quot;: Selects the most plausible label.</span>
<span class="sd">            - &quot;average&quot;: Selects the average label (sum [Pij(l) * l]).</span>

<span class="sd">        to_return: {&quot;df&quot;,&quot;ids&quot;, &quot;both&quot;}, default: df</span>
<span class="sd">            Option to choose how the predicted labels will be returned.</span>
<span class="sd">             -&quot;df&quot;: Returns a DataFrame with columns for nodes from both layers and an additional column called &quot;Predicted + self.label_name&quot;.</span>
<span class="sd">             -&quot;ids&quot;: Returns a ndarray of ints with the ids of the predicted labels.</span>
<span class="sd">             -&quot;both&quot;: Returns both the DataFrame and the ndarray with the ids in this order.</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        labels_id: ndarray</span>
<span class="sd">            Predicted labels id.</span>

<span class="sd">        labels_df: pandas DataFrame</span>
<span class="sd">            DataFrame whose columns are nodes_a, nodes_b and the predicted labels</span>


<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If Pij is provided, it will use the given probabilities; otherwise, it will compute probabilities using self.get_links_probabilities(links).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">Pij</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">estimator</span><span class="o">==</span><span class="s2">&quot;max_probability&quot;</span><span class="p">:</span>
                <span class="n">labels_id</span> <span class="o">=</span>  <span class="n">Pij</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">estimator</span><span class="o">==</span><span class="s2">&quot;mean&quot;</span><span class="p">:</span>
                <span class="n">labels_id</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">Pij</span><span class="nd">@np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">N_labels</span><span class="p">)[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])[:,</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Pij</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_links_probabilities</span><span class="p">(</span><span class="n">links</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">estimator</span><span class="o">==</span><span class="s2">&quot;max_probability&quot;</span><span class="p">:</span>
                <span class="n">labels_id</span> <span class="o">=</span> <span class="n">Pij</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">estimator</span><span class="o">==</span><span class="s2">&quot;mean&quot;</span><span class="p">:</span>
                <span class="n">labels_id</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">Pij</span><span class="nd">@np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">N_labels</span><span class="p">)[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])[:,</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">to_return</span> <span class="o">==</span> <span class="s2">&quot;df&quot;</span> <span class="ow">or</span> <span class="n">to_return</span> <span class="o">==</span> <span class="s2">&quot;both&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">links</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">to_link</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">links_training</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">links</span><span class="p">,</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
                <span class="n">decoder</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_dict_codes</span><span class="p">[</span><span class="n">n</span><span class="p">]:</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dict_codes</span><span class="p">}</span>
                <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="n">decoder</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">labels_id</span><span class="p">]</span>
                <span class="n">result_df</span> <span class="o">=</span> <span class="n">links</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">result_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s2">&quot;Predicted &quot;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">labels_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">labels</span>

                <span class="k">if</span> <span class="n">to_return</span> <span class="o">==</span> <span class="s2">&quot;df&quot;</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">result_df</span>
                <span class="k">elif</span> <span class="n">to_return</span> <span class="o">==</span> <span class="s2">&quot;both&quot;</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">result_df</span><span class="p">,</span> <span class="n">labels_id</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">links</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">to_link</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">links</span><span class="p">[</span><span class="n">links</span><span class="p">]</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">links</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
                <span class="n">to_link</span> <span class="o">=</span> <span class="n">links</span>


            <span class="n">na</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span>
            <span class="n">nb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span>

            <span class="n">decoder</span> <span class="o">=</span> <span class="p">{</span><span class="n">na</span><span class="o">.</span><span class="n">dict_codes</span><span class="p">[</span><span class="n">n</span><span class="p">]:</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">na</span><span class="o">.</span><span class="n">dict_codes</span><span class="p">}</span>
            <span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="n">decoder</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">to_link</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]]</span>

            <span class="n">decoder</span> <span class="o">=</span> <span class="p">{</span><span class="n">nb</span><span class="o">.</span><span class="n">dict_codes</span><span class="p">[</span><span class="n">n</span><span class="p">]:</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nb</span><span class="o">.</span><span class="n">dict_codes</span><span class="p">}</span>
            <span class="n">B</span> <span class="o">=</span> <span class="p">[</span><span class="n">decoder</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">to_link</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]]</span>

            <span class="n">decoder</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_dict_codes</span><span class="p">[</span><span class="n">n</span><span class="p">]:</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dict_codes</span><span class="p">}</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="n">decoder</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">labels_id</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">to_return</span> <span class="o">==</span> <span class="s2">&quot;df&quot;</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="nb">str</span><span class="p">(</span><span class="n">na</span><span class="p">):</span><span class="n">A</span><span class="p">,</span><span class="nb">str</span><span class="p">(</span><span class="n">nb</span><span class="p">):</span><span class="n">B</span><span class="p">,</span><span class="s2">&quot;Predicted &quot;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">labels_name</span><span class="p">:</span><span class="n">labels</span><span class="p">})</span>
            <span class="k">elif</span> <span class="n">to_return</span> <span class="o">==</span> <span class="s2">&quot;both&quot;</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="nb">str</span><span class="p">(</span><span class="n">na</span><span class="p">):</span><span class="n">A</span><span class="p">,</span><span class="nb">str</span><span class="p">(</span><span class="n">nb</span><span class="p">):</span><span class="n">B</span><span class="p">,</span><span class="s2">&quot;Predicted &quot;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">labels_name</span><span class="p">:</span><span class="n">labels</span><span class="p">}),</span> <span class="n">labels_id</span>

        <span class="k">elif</span> <span class="n">to_return</span> <span class="o">==</span> <span class="s2">&quot;ids&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">labels_id</span></div>


<div class="viewcode-block" id="BiNet.get_accuracy">
<a class="viewcode-back" href="../../../Classes.html#BiMMSBM.core.BiNet.get_accuracy">[docs]</a>
    <span class="k">def</span> <span class="nf">get_accuracy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">predicted_labels</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">test_labels</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">Pij</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="n">links</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">estimator</span> <span class="o">=</span> <span class="s2">&quot;max_probability&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the ratio of correctly predicted labels of the model given the MMSBM parameters. They can be measured by different estimators:</span>
<span class="sd">            -max_probability: The predicted label will be the most plausible label</span>
<span class="sd">            -mean: The predicted label will be the mean</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        predicted_labels: array-like, default:None.</span>
<span class="sd">            Array-like with the predicted labels ids given by the MMSBM. If None, predictions will be generated using</span>
<span class="sd">        the specified links and estimator.</span>

<span class="sd">        test_labels: array-like, default:None.</span>
<span class="sd">            List or array with the observed labels. If None, labels from self.labels_array are taken given pos_test_labels</span>

<span class="sd">        links: ndarray of 1 or 2 dimensions, pandas DataFrame, default: None</span>
<span class="sd">            Array with links for which label probabilities are computed.</span>
<span class="sd">            -If a 2d-array, the first column must contain the ids from nodes_a layer and the second</span>
<span class="sd">             column must contain the ids from nodes_b layers.</span>
<span class="sd">            -If a 1d-array, it must contain the positions of the links list from self.df attribute</span>
<span class="sd">            -If a pandas DataFrame, it must contain at least two columns with the name of the nodes&#39; layers</span>
<span class="sd">             and a column with the same name as the labels column from BiNet.df.</span>
<span class="sd">            -If None, self.links_training will be used.</span>


<span class="sd">        estimator: {&quot;max_probability&quot;,&quot;mean&quot;}, default: max_probability</span>
<span class="sd">            Estimator used to get the predicted labels:</span>
<span class="sd">            -max_probability: Selects the most plausible label</span>
<span class="sd">            -mean: Selects the mean label (sum [Pij(l)*l])</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        accuracy: float</span>
<span class="sd">            Ratio of correctly predicted labels to the total number of predicted labels.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#If predicted labels are not provided, it will compute them</span>
        <span class="k">if</span> <span class="n">predicted_labels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">predicted_labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_predicted_labels</span><span class="p">(</span><span class="n">links</span><span class="o">=</span><span class="n">links</span><span class="p">,</span> <span class="n">Pij</span><span class="o">=</span><span class="n">Pij</span><span class="p">,</span> <span class="n">estimator</span><span class="o">=</span><span class="n">estimator</span><span class="p">,</span> <span class="n">to_return</span><span class="o">=</span><span class="s2">&quot;ids&quot;</span><span class="p">)</span>

        <span class="c1">#If test labels are not provided, we get them from links</span>
        <span class="k">if</span> <span class="n">test_labels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">links</span><span class="p">,</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">links</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">isin</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labels_name</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;_id&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                    <span class="n">test_labels</span> <span class="o">=</span> <span class="n">links</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labels_name</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;_id&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
                <span class="k">elif</span> <span class="n">links</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">isin</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labels_name</span><span class="p">)])</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                    <span class="n">test_labels</span> <span class="o">=</span> <span class="n">links</span><span class="o">.</span><span class="n">replace</span><span class="p">({</span><span class="bp">self</span><span class="o">.</span><span class="n">labels_name</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">_dict_codes</span><span class="p">})</span><span class="o">.</span><span class="n">values</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span>

            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">links</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">links</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">test_labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels_array</span><span class="p">[</span><span class="n">links</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;Missing test label information to compare:</span>
<span class="s2">                                     -Array in test_labels with labels ids.</span>
<span class="s2">                                     -Pandas DataFrame with links and their labels in links parameter.</span>
<span class="s2">                                     -Links position of the BiNet.links_array.&quot;&quot;&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">links</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">test_labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels_training</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">predicted_labels</span><span class="o">==</span><span class="n">test_labels</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">predicted_labels</span><span class="p">)</span></div>


<div class="viewcode-block" id="BiNet.deep_copying">
<a class="viewcode-back" href="../../../Classes.html#BiMMSBM.core.BiNet.deep_copying">[docs]</a>
    <span class="k">def</span> <span class="nf">deep_copying</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs a deep copy of all parameters in the EM algorithm.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method creates deep copies of various parameters to store their current states for future reference and convergence checking.</span>

<span class="sd">        - Link Parameters:</span>
<span class="sd">            - pkl_old: Deep copy of the link probabilities (self.pkl).</span>
<span class="sd">            - omega_old: Deep copy of omega (self.omega).</span>

<span class="sd">        - Metadata parameters (for each layer):</span>
<span class="sd">            - theta_old: Deep copy of the layer&#39;s theta parameters (self.theta).</span>
<span class="sd">            - Inclusive metadata:</span>
<span class="sd">                - zeta_old: Deep copy of zeta (meta.zeta).</span>
<span class="sd">                - q_k_tau_old: Deep copy of q_k_tau (meta.q_k_tau).</span>
<span class="sd">                - omega_old: Deep copy of omega (meta.omega).</span>
<span class="sd">            - Exclusive metadata:</span>
<span class="sd">                - qka_old: Deep copy of qka (meta.qka).</span>
<span class="sd">                - omega_old: Deep copy of omega (meta.omega).</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">na</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span>

        <span class="n">nb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span>


        <span class="bp">self</span><span class="o">.</span><span class="n">pkl_old</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pkl</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">omega_old</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>


        <span class="c1">##Metas copies</span>
        <span class="k">for</span> <span class="n">layer</span> <span class="ow">in</span> <span class="p">[</span><span class="n">na</span><span class="p">,</span><span class="n">nb</span><span class="p">]:</span>
            <span class="n">layer</span><span class="o">.</span><span class="n">theta_old</span> <span class="o">=</span> <span class="n">layer</span><span class="o">.</span><span class="n">theta</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="c1">##inclusive_meta copies</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">meta</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">layer</span><span class="o">.</span><span class="n">meta_inclusives</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
                <span class="n">meta</span><span class="o">.</span><span class="n">zeta_old</span> <span class="o">=</span> <span class="n">meta</span><span class="o">.</span><span class="n">zeta</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">meta</span><span class="o">.</span><span class="n">q_k_tau_old</span> <span class="o">=</span> <span class="n">meta</span><span class="o">.</span><span class="n">q_k_tau</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">meta</span><span class="o">.</span><span class="n">omega_old</span> <span class="o">=</span> <span class="n">meta</span><span class="o">.</span><span class="n">omega</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

            <span class="c1">##exclusive_meta copies</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">meta</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">layer</span><span class="o">.</span><span class="n">meta_exclusives</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
                <span class="n">meta</span><span class="o">.</span><span class="n">qka_old</span> <span class="o">=</span> <span class="n">meta</span><span class="o">.</span><span class="n">qka</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">meta</span><span class="o">.</span><span class="n">omega_old</span> <span class="o">=</span> <span class="n">meta</span><span class="o">.</span><span class="n">omega</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span></div>


<div class="viewcode-block" id="BiNet.converges">
<a class="viewcode-back" href="../../../Classes.html#BiMMSBM.core.BiNet.converges">[docs]</a>
    <span class="k">def</span> <span class="nf">converges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if the parameters have converged during the EM procedure.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            True if the parameters have converged, False otherwise.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Convergence is determined based on the tolerance (self.tol) set for the model.</span>

<span class="sd">        - Meta Convergence:</span>
<span class="sd">            - Checks convergence for each layer&#39;s theta and metadata parameters.</span>
<span class="sd">            - Metadata parameters include zeta, q_k_tau, and omega for both inclusive and exclusive metadata.</span>

<span class="sd">        - Links Convergence:</span>
<span class="sd">            - Checks convergence for pkl (link probabilities) and omega parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">na</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span>

        <span class="n">nb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span>

        <span class="n">tol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tol</span>


        <span class="c1">##Metas convergence</span>
        <span class="k">for</span> <span class="n">layer</span> <span class="ow">in</span> <span class="p">[</span><span class="n">na</span><span class="p">,</span><span class="n">nb</span><span class="p">]:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">finished</span><span class="p">(</span><span class="n">layer</span><span class="o">.</span><span class="n">theta_old</span><span class="p">,</span><span class="n">layer</span><span class="o">.</span><span class="n">theta</span><span class="p">,</span><span class="n">tol</span><span class="p">):</span> <span class="k">return</span> <span class="kc">False</span>
            <span class="c1">##inclusive_meta convergence</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">meta</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">layer</span><span class="o">.</span><span class="n">meta_inclusives</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">finished</span><span class="p">(</span><span class="n">meta</span><span class="o">.</span><span class="n">zeta_old</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">zeta</span><span class="p">,</span><span class="n">tol</span><span class="p">):</span> <span class="k">return</span> <span class="kc">False</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">finished</span><span class="p">(</span><span class="n">meta</span><span class="o">.</span><span class="n">q_k_tau_old</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">q_k_tau</span><span class="p">,</span><span class="n">tol</span><span class="p">):</span> <span class="k">return</span> <span class="kc">False</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">finished</span><span class="p">(</span><span class="n">meta</span><span class="o">.</span><span class="n">omega_old</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">omega</span><span class="p">,</span><span class="n">tol</span><span class="p">):</span> <span class="k">return</span> <span class="kc">False</span>

            <span class="c1">##exclusive_meta convergence</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">meta</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">layer</span><span class="o">.</span><span class="n">meta_exclusives</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">finished</span><span class="p">(</span><span class="n">meta</span><span class="o">.</span><span class="n">qka_old</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">qka</span><span class="p">,</span><span class="n">tol</span><span class="p">):</span> <span class="k">return</span> <span class="kc">False</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">finished</span><span class="p">(</span><span class="n">meta</span><span class="o">.</span><span class="n">omega_old</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">omega</span><span class="p">,</span><span class="n">tol</span><span class="p">):</span> <span class="k">return</span> <span class="kc">False</span>

        <span class="c1">#links convergence</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">finished</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pkl_old</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">pkl</span><span class="p">,</span><span class="n">tol</span><span class="p">):</span><span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">finished</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">omega_old</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="p">,</span><span class="n">tol</span><span class="p">):</span><span class="k">return</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="BiNet.add_node">
<a class="viewcode-back" href="../../../Classes.html#BiMMSBM.core.BiNet.add_node">[docs]</a>
    <span class="k">def</span> <span class="nf">add_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">,</span> <span class="n">node_name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a node to the layer.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id : int</span>
<span class="sd">            Unique identifier for the node</span>
<span class="sd">        node_name : str, optional</span>
<span class="sd">            Name of the node, defaults to None</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            The created node dictionary</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If node_id already exists</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">node_id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Node </span><span class="si">{</span><span class="n">node_id</span><span class="si">}</span><span class="s2"> already exists!&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node_id</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">node_name</span><span class="p">}</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node_id</span><span class="p">]</span></div>


<div class="viewcode-block" id="BiNet.add_nodes_from_list">
<a class="viewcode-back" href="../../../Classes.html#BiMMSBM.core.BiNet.add_nodes_from_list">[docs]</a>
    <span class="k">def</span> <span class="nf">add_nodes_from_list</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_list</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add multiple nodes from a list.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_list : list</span>
<span class="sd">            List of node identifiers</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">node_id</span> <span class="ow">in</span> <span class="n">node_list</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">node_id</span><span class="p">)</span></div>


<div class="viewcode-block" id="BiNet.add_metadata_to_node">
<a class="viewcode-back" href="../../../Classes.html#BiMMSBM.core.BiNet.add_metadata_to_node">[docs]</a>
    <span class="k">def</span> <span class="nf">add_metadata_to_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">,</span> <span class="n">meta_name</span><span class="p">,</span> <span class="n">meta_value</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add metadata to a specific node.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id : int</span>
<span class="sd">            Node identifier</span>
<span class="sd">        meta_name : str</span>
<span class="sd">            Name of the metadata column</span>
<span class="sd">        meta_value : any</span>
<span class="sd">            Value of the metadata</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        KeyError</span>
<span class="sd">            If node_id or meta_name doesn&#39;t exist</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">node_id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Node </span><span class="si">{</span><span class="n">node_id</span><span class="si">}</span><span class="s2"> doesn&#39;t exist!&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">meta_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Metadata </span><span class="si">{</span><span class="n">meta_name</span><span class="si">}</span><span class="s2"> doesn&#39;t exist!&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node_id</span><span class="p">][</span><span class="n">meta_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">meta_value</span></div>


<div class="viewcode-block" id="BiNet.get_node_metadata">
<a class="viewcode-back" href="../../../Classes.html#BiMMSBM.core.BiNet.get_node_metadata">[docs]</a>
    <span class="k">def</span> <span class="nf">get_node_metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">,</span> <span class="n">meta_name</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get metadata value for a specific node.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id : int</span>
<span class="sd">            Node identifier</span>
<span class="sd">        meta_name : str</span>
<span class="sd">            Name of the metadata column</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        any</span>
<span class="sd">            The metadata value</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        KeyError</span>
<span class="sd">            If node_id or meta_name doesn&#39;t exist</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">node_id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Node </span><span class="si">{</span><span class="n">node_id</span><span class="si">}</span><span class="s2"> doesn&#39;t exist!&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">meta_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Metadata </span><span class="si">{</span><span class="n">meta_name</span><span class="si">}</span><span class="s2"> doesn&#39;t exist!&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node_id</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">meta_name</span><span class="p">)</span></div>


<div class="viewcode-block" id="BiNet.get_all_nodes_metadata">
<a class="viewcode-back" href="../../../Classes.html#BiMMSBM.core.BiNet.get_all_nodes_metadata">[docs]</a>
    <span class="k">def</span> <span class="nf">get_all_nodes_metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">meta_name</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get metadata values for all nodes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        meta_name : str</span>
<span class="sd">            Name of the metadata column</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            Dictionary mapping node IDs to their metadata values</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        KeyError</span>
<span class="sd">            If meta_name doesn&#39;t exist</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">meta_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Metadata </span><span class="si">{</span><span class="n">meta_name</span><span class="si">}</span><span class="s2"> doesn&#39;t exist!&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">node_id</span><span class="p">:</span> <span class="n">node_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">meta_name</span><span class="p">)</span> <span class="k">for</span> <span class="n">node_id</span><span class="p">,</span> <span class="n">node_data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span></div>


<div class="viewcode-block" id="BiNet.remove_node">
<a class="viewcode-back" href="../../../Classes.html#BiMMSBM.core.BiNet.remove_node">[docs]</a>
    <span class="k">def</span> <span class="nf">remove_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove a node from the layer.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_id : int</span>
<span class="sd">            Node identifier</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        KeyError</span>
<span class="sd">            If node_id doesn&#39;t exist</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">node_id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Node </span><span class="si">{</span><span class="n">node_id</span><span class="si">}</span><span class="s2"> doesn&#39;t exist!&quot;</span><span class="p">)</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node_id</span><span class="p">]</span></div>


<div class="viewcode-block" id="BiNet.remove_metadata">
<a class="viewcode-back" href="../../../Classes.html#BiMMSBM.core.BiNet.remove_metadata">[docs]</a>
    <span class="k">def</span> <span class="nf">remove_metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">meta_name</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove a metadata column from all nodes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        meta_name : str</span>
<span class="sd">            Name of the metadata column</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        KeyError</span>
<span class="sd">            If meta_name doesn&#39;t exist</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">meta_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Metadata </span><span class="si">{</span><span class="n">meta_name</span><span class="si">}</span><span class="s2"> doesn&#39;t exist!&quot;</span><span class="p">)</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="n">meta_name</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">node_data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">meta_name</span> <span class="ow">in</span> <span class="n">node_data</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">node_data</span><span class="p">[</span><span class="n">meta_name</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">N_meta</span> <span class="o">-=</span> <span class="mi">1</span></div>


<div class="viewcode-block" id="BiNet.clear">
<a class="viewcode-back" href="../../../Classes.html#BiMMSBM.core.BiNet.clear">[docs]</a>
    <span class="k">def</span> <span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove all nodes and metadata from the layer.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">N_meta</span> <span class="o">=</span> <span class="mi">0</span></div>
</div>






</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Oscar Fajardo Fontiveros.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>